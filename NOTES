A Monitor has 

 attribute :enabled (true or false) which says whether the admin
 *wants* it to be up

 attribute :health which takes some value denoting whether it is actually
 up, or is flakey, or is down, or has unknown status

Monitors listen for Events, which may be things like :enable or
:disable or :child_exited.  Event handlers are defined using the
'listen' class method.  Event handlers may also signal events of their own, 
or may raise Alerts

Monitors may also invoke code periodically using the 'every' class
method.  These timed handlers can poll for service status, signal events, 
send alerts etc just as signal handlers can

Alerts notify people that something has happened.  Alerts applicable
to a given monitor are named using the ::alert class method and then
created using the #alert instance method.  An alert is any object which
accepts #call with a string 'message' argument, which should cause it to somehow
send that message somewhere

  alert :oncall, Lizard::Alert::Pager.new :number=>'5551234'
  every 1.hour do
    alert :oncall, "We hate you"
  end

Collections are data structures for collecting historical data:
e.g. we might monitor service response time every minute and notify
flakey health if it consistently exceeds a a threshold, or we might
collect a timestamp every time a process restarts and use it to
trigger an alert if it dies too frequently. A collection is specified
with a maximum age, and discards collected values exceeding that age.

Collections are named using the class method ::collect.  Code in
handlers may add values to a collection using the << notation

There are some handy methods on collections to do things like
averages, exponential time-weighted averages, and suchlike so we can
make decisions on the data in them.

A Process is a subclass of Monitor which includes a child process
under the control of Lizard.  It has attributes :running and :pid.
The class methods ::start and ::stop define how it is started and
stopped

Output and error streams from child processes are captured using the
::log class method, with which they can be monitored for particular
messages (which may signal events, send alerts, the usual drill) or sent
onto somewhere else (by default, syslog)

    log :stdout, Syslogger.new(facility: :local1, priority: :debug) do |l|
      if l.match /FATAL/ then signal :dead end
    end


